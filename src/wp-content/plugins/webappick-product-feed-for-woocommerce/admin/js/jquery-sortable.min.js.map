{"version":3,"sources":["jquery-sortable.js"],"names":["Symbol","iterator","nested","$","pluginName","undefined","containerDefaults","drag","groupDefaults","exclude","containerPath","containerSelector","afterMove","distance","draggedClass","handle","itemPath","itemSelector","bodyClass","onDrag","isValidTarget","css","$item","position","addClass","onDragStart","container","removeClass","onMousedown","event","preventDefault","group","options","placeholderClass","removeAttr","_super","target","nodeName","match","placeholder","pullPlaceholder","parentIsContainer","result","sortable","serialize","$parent","$children","extend","data","containerGroups","groupCounter","emptyBox","subContainers","drop","subContainerKey","x","Math","i","length","d","a","b","top","offsetMethod","left","parseInt","el","getRelativePosition","element","sortByDistanceDesc","tolerance","offset","pointer","pos","distances","dimensions","outerWidth","outerHeight","dim","dropProxy","dragProxy","sort","proxy","ContainerGroup","get","this","containers","rootGroup","closestItem","item","disabled","itemDimensions","right","which","find","originalEvent","bottom","on","eventNames","start","dragInit","searchValidTarget","push","setPointer","dragInitDone","prototype","dragging","setupDelayTimer","box","itemContainer","e","toggleListeners","onCancel","detach","delayMet","clearDimensions","clearOffsetParent","relativePointer","lastPointer","sameResultBox","t","offsetParent","lastRelativePointer","getContainer","getContainerDimensions","onDrop","movePlaceholder","lastAppendedItem","$getOffsetParent","containerDimensions","setDimensions","closest","method","getPointer","getItemOffsetParent","that","distanceMet","events","$document","pageX","pageY","currentPointer","clearTimeout","abs","_mouseDelayTimer","o","touches","scroll","_clearDimensions","delay","each","setTimeout","callback","traverse","object","isValidDrag","Container","validTarget","_destroy","inUpperHalf","xCenter","inLeftHalf","index","getItemDimensions","hasChildGroup","items","getContainerGroup","childGroup","childContainers","yCenter","height","path","_serialize","width","removeData","enable","$getChildren","parent","type","isContainer","childType","children","selector","not","map","disable","off","grep","val","destroy","args","$t","API"],"mappings":"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","file":"jquery-sortable.min.js","sourcesContent":["/* ===================================================\r\n *  jquery-sortable.js v0.9.13\r\n *  http://johnny.github.com/jquery-sortable/\r\n * ===================================================\r\n *  Copyright (c) 2012 Jonas von Andrian\r\n *  All rights reserved.\r\n *\r\n *  Redistribution and use in source and binary forms, with or without\r\n *  modification, are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n *  * The name of the author may not be used to endorse or promote products\r\n *    derived from this software without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n *  DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n * ========================================================== */\r\n/* eslint-disable */\r\n!function ( $, window, pluginName, undefined){\r\n    var containerDefaults = {\r\n            // If true, items can be dragged from this container\r\n            drag: true,\r\n            // If true, items can be droped onto this container\r\n            drop: true,\r\n            // Exclude items from being draggable, if the\r\n            // selector matches the item\r\n            exclude: \"\",\r\n            // If true, search for nested containers within an item.If you nest containers,\r\n            // either the original selector with which you call the plugin must only match the top containers,\r\n            // or you need to specify a group (see the bootstrap nav example)\r\n            nested: true,\r\n            // If true, the items are assumed to be arranged vertically\r\n            vertical: true\r\n        }, // end container defaults\r\n        groupDefaults = {\r\n            // This is executed after the placeholder has been moved.\r\n            // $closestItemOrContainer contains the closest item, the placeholder\r\n            // has been put at or the closest empty Container, the placeholder has\r\n            // been appended to.\r\n            afterMove: function ($placeholder, container, $closestItemOrContainer) {\r\n            },\r\n            // The exact css path between the container and its items, e.g. \"> tbody\"\r\n            containerPath: \"\",\r\n            // The css selector of the containers\r\n            containerSelector: \"ol, ul\",\r\n            // Distance the mouse has to travel to start dragging\r\n            distance: 0,\r\n            // Time in milliseconds after mousedown until dragging should start.\r\n            // This option can be used to prevent unwanted drags when clicking on an element.\r\n            delay: 0,\r\n            // The css selector of the drag handle\r\n            handle: \"\",\r\n            // The exact css path between the item and its subcontainers.\r\n            // It should only match the immediate items of a container.\r\n            // No item of a subcontainer should be matched. E.g. for ol>div>li the itemPath is \"> div\"\r\n            itemPath: \"\",\r\n            // The css selector of the items\r\n            itemSelector: \"li\",\r\n            // The class given to \"body\" while an item is being dragged\r\n            bodyClass: \"dragging\",\r\n            // The class giving to an item while being dragged\r\n            draggedClass: \"dragged\",\r\n            // Check if the dragged item may be inside the container.\r\n            // Use with care, since the search for a valid container entails a depth first search\r\n            // and may be quite expensive.\r\n            isValidTarget: function ($item, container) {\r\n                return true\r\n            },\r\n            // Executed before onDrop if placeholder is detached.\r\n            // This happens if pullPlaceholder is set to false and the drop occurs outside a container.\r\n            onCancel: function ($item, container, _super, event) {\r\n            },\r\n            // Executed at the beginning of a mouse move event.\r\n            // The Placeholder has not been moved yet.\r\n            onDrag: function ($item, position, _super, event) {\r\n                $item.css(position)\r\n            },\r\n            // Called after the drag has been started,\r\n            // that is the mouse button is being held down and\r\n            // the mouse is moving.\r\n            // The container is the closest initialized container.\r\n            // Therefore it might not be the container, that actually contains the item.\r\n            onDragStart: function ($item, container, _super, event) {\r\n                $item.css({\r\n                    height: $item.outerHeight(),\r\n                    width: $item.outerWidth()\r\n                })\r\n                $item.addClass(container.group.options.draggedClass)\r\n                $(\"body\").addClass(container.group.options.bodyClass)\r\n            },\r\n            // Called when the mouse button is being released\r\n            onDrop: function ($item, container, _super, event) {\r\n                $item.removeClass(container.group.options.draggedClass).removeAttr(\"style\")\r\n                $(\"body\").removeClass(container.group.options.bodyClass)\r\n            },\r\n            // Called on mousedown. If falsy value is returned, the dragging will not start.\r\n            // Ignore if element clicked is input, select or textarea\r\n            onMousedown: function ($item, _super, event) {\r\n                if (!event.target.nodeName.match(/^(input|select|textarea)$/i)) {\r\n                    event.preventDefault()\r\n                    return true\r\n                }\r\n            },\r\n            // The class of the placeholder (must match placeholder option markup)\r\n            placeholderClass: \"placeholder\",\r\n            // Template for the placeholder. Can be any valid jQuery input\r\n            // e.g. a string, a DOM element.\r\n            // The placeholder must have the class \"placeholder\"\r\n            placeholder: '<li class=\"placeholder\"></li>',\r\n            // If true, the position of the placeholder is calculated on every mousemove.\r\n            // If false, it is only calculated when the mouse is above a container.\r\n            pullPlaceholder: true,\r\n            // Specifies serialization of the container group.\r\n            // The pair $parent/$children is either container/items or item/subcontainers.\r\n            serialize: function ($parent, $children, parentIsContainer) {\r\n                var result = $.extend({}, $parent.data())\r\n\r\n                if(parentIsContainer)\r\n                    return [$children]\r\n                else if ($children[0]){\r\n                    result.children = $children\r\n                }\r\n\r\n                delete result.subContainers\r\n                delete result.sortable\r\n\r\n                return result\r\n            },\r\n            // Set tolerance while dragging. Positive values decrease sensitivity,\r\n            // negative values increase it.\r\n            tolerance: 0\r\n        }, // end group defaults\r\n        containerGroups = {},\r\n        groupCounter = 0,\r\n        emptyBox = {\r\n            left: 0,\r\n            top: 0,\r\n            bottom: 0,\r\n            right:0\r\n        },\r\n        eventNames = {\r\n            start: \"touchstart.sortable mousedown.sortable\",\r\n            drop: \"touchend.sortable touchcancel.sortable mouseup.sortable\",\r\n            drag: \"touchmove.sortable mousemove.sortable\",\r\n            scroll: \"scroll.sortable\"\r\n        },\r\n        subContainerKey = \"subContainers\"\r\n\r\n    /*\r\n     * a is Array [left, right, top, bottom]\r\n     * b is array [left, top]\r\n     */\r\n    function d(a,b) {\r\n        var x = Math.max(0, a[0] - b[0], b[0] - a[1]),\r\n            y = Math.max(0, a[2] - b[1], b[1] - a[3])\r\n        return x+y;\r\n    }\r\n\r\n    function setDimensions(array, dimensions, tolerance, useOffset) {\r\n        var i = array.length,\r\n            offsetMethod = useOffset ? \"offset\" : \"position\"\r\n        tolerance = tolerance || 0\r\n\r\n        while(i--){\r\n            var el = array[i].el ? array[i].el : $(array[i]),\r\n            // use fitting method\r\n                pos = el[offsetMethod]()\r\n            pos.left += parseInt(el.css('margin-left'), 10)\r\n            pos.top += parseInt(el.css('margin-top'),10)\r\n            dimensions[i] = [\r\n                pos.left - tolerance,\r\n                pos.left + el.outerWidth() + tolerance,\r\n                pos.top - tolerance,\r\n                pos.top + el.outerHeight() + tolerance\r\n            ]\r\n        }\r\n    }\r\n\r\n    function getRelativePosition(pointer, element) {\r\n        var offset = element.offset()\r\n        return {\r\n            left: pointer.left - offset.left,\r\n            top: pointer.top - offset.top\r\n        }\r\n    }\r\n\r\n    function sortByDistanceDesc(dimensions, pointer, lastPointer) {\r\n        pointer = [pointer.left, pointer.top]\r\n        lastPointer = lastPointer && [lastPointer.left, lastPointer.top]\r\n\r\n        var dim,\r\n            i = dimensions.length,\r\n            distances = []\r\n\r\n        while(i--){\r\n            dim = dimensions[i]\r\n            distances[i] = [i,d(dim,pointer), lastPointer && d(dim, lastPointer)]\r\n        }\r\n        distances = distances.sort(function  (a,b) {\r\n            return b[1] - a[1] || b[2] - a[2] || b[0] - a[0]\r\n        })\r\n\r\n        // last entry is the closest\r\n        return distances\r\n    }\r\n\r\n    function ContainerGroup(options) {\r\n        this.options = $.extend({}, groupDefaults, options)\r\n        this.containers = []\r\n\r\n        if(!this.options.rootGroup){\r\n            this.scrollProxy = $.proxy(this.scroll, this)\r\n            this.dragProxy = $.proxy(this.drag, this)\r\n            this.dropProxy = $.proxy(this.drop, this)\r\n            this.placeholder = $(this.options.placeholder)\r\n\r\n            if(!options.isValidTarget)\r\n                this.options.isValidTarget = undefined\r\n        }\r\n    }\r\n\r\n    ContainerGroup.get = function  (options) {\r\n        if(!containerGroups[options.group]) {\r\n            if(options.group === undefined)\r\n                options.group = groupCounter ++\r\n\r\n            containerGroups[options.group] = new ContainerGroup(options)\r\n        }\r\n\r\n        return containerGroups[options.group]\r\n    }\r\n\r\n    ContainerGroup.prototype = {\r\n        dragInit: function  (e, itemContainer) {\r\n            this.$document = $(itemContainer.el[0].ownerDocument)\r\n\r\n            // get item to drag\r\n            var closestItem = $(e.target).closest(this.options.itemSelector);\r\n            // using the length of this item, prevents the plugin from being started if there is no handle being clicked on.\r\n            // this may also be helpful in instantiating multidrag.\r\n            if (closestItem.length) {\r\n                this.item = closestItem;\r\n                this.itemContainer = itemContainer;\r\n                if (this.item.is(this.options.exclude) || !this.options.onMousedown(this.item, groupDefaults.onMousedown, e)) {\r\n                    return;\r\n                }\r\n                this.setPointer(e);\r\n                this.toggleListeners('on');\r\n                this.setupDelayTimer();\r\n                this.dragInitDone = true;\r\n            }\r\n        },\r\n        drag: function  (e) {\r\n            if(!this.dragging){\r\n                if(!this.distanceMet(e) || !this.delayMet)\r\n                    return\r\n\r\n                this.options.onDragStart(this.item, this.itemContainer, groupDefaults.onDragStart, e)\r\n                this.item.before(this.placeholder)\r\n                this.dragging = true\r\n            }\r\n\r\n            this.setPointer(e)\r\n            // place item under the cursor\r\n            this.options.onDrag(this.item,\r\n                getRelativePosition(this.pointer, this.item.offsetParent()),\r\n                groupDefaults.onDrag,\r\n                e)\r\n\r\n            var p = this.getPointer(e),\r\n                box = this.sameResultBox,\r\n                t = this.options.tolerance\r\n\r\n            if(!box || box.top - t > p.top || box.bottom + t < p.top || box.left - t > p.left || box.right + t < p.left)\r\n                if(!this.searchValidTarget()){\r\n                    this.placeholder.detach()\r\n                    this.lastAppendedItem = undefined\r\n                }\r\n        },\r\n        drop: function  (e) {\r\n            this.toggleListeners('off')\r\n\r\n            this.dragInitDone = false\r\n\r\n            if(this.dragging){\r\n                // processing Drop, check if placeholder is detached\r\n                if(this.placeholder.closest(\"html\")[0]){\r\n                    this.placeholder.before(this.item).detach()\r\n                } else {\r\n                    this.options.onCancel(this.item, this.itemContainer, groupDefaults.onCancel, e)\r\n                }\r\n                this.options.onDrop(this.item, this.getContainer(this.item), groupDefaults.onDrop, e)\r\n\r\n                // cleanup\r\n                this.clearDimensions()\r\n                this.clearOffsetParent()\r\n                this.lastAppendedItem = this.sameResultBox = undefined\r\n                this.dragging = false\r\n            }\r\n        },\r\n        searchValidTarget: function  (pointer, lastPointer) {\r\n            if(!pointer){\r\n                pointer = this.relativePointer || this.pointer\r\n                lastPointer = this.lastRelativePointer || this.lastPointer\r\n            }\r\n\r\n            var distances = sortByDistanceDesc(this.getContainerDimensions(),\r\n                    pointer,\r\n                    lastPointer),\r\n                i = distances.length\r\n\r\n            while(i--){\r\n                var index = distances[i][0],\r\n                    distance = distances[i][1]\r\n\r\n                if(!distance || this.options.pullPlaceholder){\r\n                    var container = this.containers[index]\r\n                    if(!container.disabled){\r\n                        if(!this.$getOffsetParent()){\r\n                            var offsetParent = container.getItemOffsetParent()\r\n                            pointer = getRelativePosition(pointer, offsetParent)\r\n                            lastPointer = getRelativePosition(lastPointer, offsetParent)\r\n                        }\r\n                        if(container.searchValidTarget(pointer, lastPointer))\r\n                            return true\r\n                    }\r\n                }\r\n            }\r\n            if(this.sameResultBox)\r\n                this.sameResultBox = undefined\r\n        },\r\n        movePlaceholder: function  (container, item, method, sameResultBox) {\r\n            var lastAppendedItem = this.lastAppendedItem\r\n            if(!sameResultBox && lastAppendedItem && lastAppendedItem[0] === item[0])\r\n                return;\r\n\r\n            item[method](this.placeholder)\r\n            this.lastAppendedItem = item\r\n            this.sameResultBox = sameResultBox\r\n            this.options.afterMove(this.placeholder, container, item)\r\n        },\r\n        getContainerDimensions: function  () {\r\n            if(!this.containerDimensions)\r\n                setDimensions(this.containers, this.containerDimensions = [], this.options.tolerance, !this.$getOffsetParent())\r\n            return this.containerDimensions\r\n        },\r\n        getContainer: function  (element) {\r\n            return element.closest(this.options.containerSelector).data(pluginName)\r\n        },\r\n        $getOffsetParent: function  () {\r\n            if(this.offsetParent === undefined){\r\n                var i = this.containers.length - 1,\r\n                    offsetParent = this.containers[i].getItemOffsetParent()\r\n\r\n                if(!this.options.rootGroup){\r\n                    while(i--){\r\n                        if(offsetParent[0] != this.containers[i].getItemOffsetParent()[0]){\r\n                            // If every container has the same offset parent,\r\n                            // use position() which is relative to this parent,\r\n                            // otherwise use offset()\r\n                            // compare #setDimensions\r\n                            offsetParent = false\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                this.offsetParent = offsetParent\r\n            }\r\n            return this.offsetParent\r\n        },\r\n        setPointer: function (e) {\r\n            var pointer = this.getPointer(e)\r\n\r\n            if(this.$getOffsetParent()){\r\n                var relativePointer = getRelativePosition(pointer, this.$getOffsetParent())\r\n                this.lastRelativePointer = this.relativePointer\r\n                this.relativePointer = relativePointer\r\n            }\r\n\r\n            this.lastPointer = this.pointer\r\n            this.pointer = pointer\r\n        },\r\n        distanceMet: function (e) {\r\n            var currentPointer = this.getPointer(e)\r\n            return (Math.max(\r\n                Math.abs(this.pointer.left - currentPointer.left),\r\n                Math.abs(this.pointer.top - currentPointer.top)\r\n            ) >= this.options.distance)\r\n        },\r\n        getPointer: function(e) {\r\n            var o = e.originalEvent || e.originalEvent.touches && e.originalEvent.touches[0]\r\n            return {\r\n                left: e.pageX || o.pageX,\r\n                top: e.pageY || o.pageY\r\n            }\r\n        },\r\n        setupDelayTimer: function () {\r\n            var that = this\r\n            this.delayMet = !this.options.delay\r\n\r\n            // init delay timer if needed\r\n            if (!this.delayMet) {\r\n                clearTimeout(this._mouseDelayTimer);\r\n                this._mouseDelayTimer = setTimeout(function() {\r\n                    that.delayMet = true\r\n                }, this.options.delay)\r\n            }\r\n        },\r\n        scroll: function  (e) {\r\n            this.clearDimensions()\r\n            this.clearOffsetParent() // TODO is this needed?\r\n        },\r\n        toggleListeners: function (method) {\r\n            var that = this,\r\n                events = ['drag','drop','scroll']\r\n\r\n            $.each(events,function  (i,event) {\r\n                that.$document[method](eventNames[event], that[event + 'Proxy'])\r\n            })\r\n        },\r\n        clearOffsetParent: function () {\r\n            this.offsetParent = undefined\r\n        },\r\n        // Recursively clear container and item dimensions\r\n        clearDimensions: function  () {\r\n            this.traverse(function(object){\r\n                object._clearDimensions()\r\n            })\r\n        },\r\n        traverse: function(callback) {\r\n            callback(this)\r\n            var i = this.containers.length\r\n            while(i--){\r\n                this.containers[i].traverse(callback)\r\n            }\r\n        },\r\n        _clearDimensions: function(){\r\n            this.containerDimensions = undefined\r\n        },\r\n        _destroy: function () {\r\n            containerGroups[this.options.group] = undefined\r\n        }\r\n    }\r\n\r\n    function Container(element, options) {\r\n        this.el = element\r\n        this.options = $.extend( {}, containerDefaults, options)\r\n\r\n        this.group = ContainerGroup.get(this.options)\r\n        this.rootGroup = this.options.rootGroup || this.group\r\n        this.handle = this.rootGroup.options.handle || this.rootGroup.options.itemSelector\r\n\r\n        var itemPath = this.rootGroup.options.itemPath\r\n        this.target = itemPath ? this.el.find(itemPath) : this.el\r\n\r\n        this.target.on(eventNames.start, this.handle, $.proxy(this.dragInit, this))\r\n\r\n        if(this.options.drop)\r\n            this.group.containers.push(this)\r\n    }\r\n\r\n    Container.prototype = {\r\n        dragInit: function  (e) {\r\n            var rootGroup = this.rootGroup\r\n\r\n            if( !this.disabled &&\r\n                !rootGroup.dragInitDone &&\r\n                this.options.drag &&\r\n                this.isValidDrag(e)) {\r\n                rootGroup.dragInit(e, this)\r\n            }\r\n        },\r\n        isValidDrag: function(e) {\r\n            return e.which == 1 ||\r\n            e.type == \"touchstart\" && e.originalEvent.touches.length == 1\r\n        },\r\n        searchValidTarget: function  (pointer, lastPointer) {\r\n            var distances = sortByDistanceDesc(this.getItemDimensions(),\r\n                    pointer,\r\n                    lastPointer),\r\n                i = distances.length,\r\n                rootGroup = this.rootGroup,\r\n                validTarget = !rootGroup.options.isValidTarget ||\r\n                    rootGroup.options.isValidTarget(rootGroup.item, this)\r\n\r\n            if(!i && validTarget){\r\n                rootGroup.movePlaceholder(this, this.target, \"append\")\r\n                return true\r\n            } else\r\n                while(i--){\r\n                    var index = distances[i][0],\r\n                        distance = distances[i][1]\r\n                    if(!distance && this.hasChildGroup(index)){\r\n                        var found = this.getContainerGroup(index).searchValidTarget(pointer, lastPointer)\r\n                        if(found)\r\n                            return true\r\n                    }\r\n                    else if(validTarget){\r\n                        this.movePlaceholder(index, pointer)\r\n                        return true\r\n                    }\r\n                }\r\n        },\r\n        movePlaceholder: function  (index, pointer) {\r\n            var item = $(this.items[index]),\r\n                dim = this.itemDimensions[index],\r\n                method = \"after\",\r\n                width = item.outerWidth(),\r\n                height = item.outerHeight(),\r\n                offset = item.offset(),\r\n                sameResultBox = {\r\n                    left: offset.left,\r\n                    right: offset.left + width,\r\n                    top: offset.top,\r\n                    bottom: offset.top + height\r\n                }\r\n            if(this.options.vertical){\r\n                var yCenter = (dim[2] + dim[3]) / 2,\r\n                    inUpperHalf = pointer.top <= yCenter\r\n                if(inUpperHalf){\r\n                    method = \"before\"\r\n                    sameResultBox.bottom -= height / 2\r\n                } else\r\n                    sameResultBox.top += height / 2\r\n            } else {\r\n                var xCenter = (dim[0] + dim[1]) / 2,\r\n                    inLeftHalf = pointer.left <= xCenter\r\n                if(inLeftHalf){\r\n                    method = \"before\"\r\n                    sameResultBox.right -= width / 2\r\n                } else\r\n                    sameResultBox.left += width / 2\r\n            }\r\n            if(this.hasChildGroup(index))\r\n                sameResultBox = emptyBox\r\n            this.rootGroup.movePlaceholder(this, item, method, sameResultBox)\r\n        },\r\n        getItemDimensions: function  () {\r\n            if(!this.itemDimensions){\r\n                this.items = this.$getChildren(this.el, \"item\").filter(\r\n                    \":not(.\" + this.group.options.placeholderClass + \", .\" + this.group.options.draggedClass + \")\"\r\n                ).get()\r\n                setDimensions(this.items, this.itemDimensions = [], this.options.tolerance)\r\n            }\r\n            return this.itemDimensions\r\n        },\r\n        getItemOffsetParent: function  () {\r\n            var offsetParent,\r\n                el = this.el\r\n            // Since el might be empty we have to check el itself and\r\n            // can not do something like el.children().first().offsetParent()\r\n            if(el.css(\"position\") === \"relative\" || el.css(\"position\") === \"absolute\"  || el.css(\"position\") === \"fixed\")\r\n                offsetParent = el\r\n            else\r\n                offsetParent = el.offsetParent()\r\n            return offsetParent\r\n        },\r\n        hasChildGroup: function (index) {\r\n            return this.options.nested && this.getContainerGroup(index)\r\n        },\r\n        getContainerGroup: function  (index) {\r\n            var childGroup = $.data(this.items[index], subContainerKey)\r\n            if( childGroup === undefined){\r\n                var childContainers = this.$getChildren(this.items[index], \"container\")\r\n                childGroup = false\r\n\r\n                if(childContainers[0]){\r\n                    var options = $.extend({}, this.options, {\r\n                        rootGroup: this.rootGroup,\r\n                        group: groupCounter ++\r\n                    })\r\n                    childGroup = childContainers[pluginName](options).data(pluginName).group\r\n                }\r\n                $.data(this.items[index], subContainerKey, childGroup)\r\n            }\r\n            return childGroup\r\n        },\r\n        $getChildren: function (parent, type) {\r\n            var options = this.rootGroup.options,\r\n                path = options[type + \"Path\"],\r\n                selector = options[type + \"Selector\"]\r\n\r\n            parent = $(parent)\r\n            if(path)\r\n                parent = parent.find(path)\r\n\r\n            return parent.children(selector)\r\n        },\r\n        _serialize: function (parent, isContainer) {\r\n            var that = this,\r\n                childType = isContainer ? \"item\" : \"container\",\r\n\r\n                children = this.$getChildren(parent, childType).not(this.options.exclude).map(function () {\r\n                    return that._serialize($(this), !isContainer)\r\n                }).get()\r\n\r\n            return this.rootGroup.options.serialize(parent, children, isContainer)\r\n        },\r\n        traverse: function(callback) {\r\n            $.each(this.items || [], function(item){\r\n                var group = $.data(this, subContainerKey)\r\n                if(group)\r\n                    group.traverse(callback)\r\n            });\r\n\r\n            callback(this)\r\n        },\r\n        _clearDimensions: function  () {\r\n            this.itemDimensions = undefined\r\n        },\r\n        _destroy: function() {\r\n            var that = this;\r\n\r\n            this.target.off(eventNames.start, this.handle);\r\n            this.el.removeData(pluginName)\r\n\r\n            if(this.options.drop)\r\n                this.group.containers = $.grep(this.group.containers, function(val){\r\n                    return val != that\r\n                })\r\n\r\n            $.each(this.items || [], function(){\r\n                $.removeData(this, subContainerKey)\r\n            })\r\n        }\r\n    }\r\n\r\n    var API = {\r\n        enable: function() {\r\n            this.traverse(function(object){\r\n                object.disabled = false\r\n            })\r\n        },\r\n        disable: function (){\r\n            this.traverse(function(object){\r\n                object.disabled = true\r\n            })\r\n        },\r\n        serialize: function () {\r\n            return this._serialize(this.el, true)\r\n        },\r\n        refresh: function() {\r\n            this.traverse(function(object){\r\n                object._clearDimensions()\r\n            })\r\n        },\r\n        destroy: function () {\r\n            this.traverse(function(object){\r\n                object._destroy();\r\n            })\r\n        }\r\n    }\r\n\r\n    $.extend(Container.prototype, API)\r\n\r\n    /**\r\n     * jQuery API\r\n     *\r\n     * Parameters are\r\n     *   either options on init\r\n     *   or a method name followed by arguments to pass to the method\r\n     */\r\n    $.fn[pluginName] = function(methodOrOptions) {\r\n        var args = Array.prototype.slice.call(arguments, 1)\r\n\r\n        return this.map(function(){\r\n            var $t = $(this),\r\n                object = $t.data(pluginName)\r\n\r\n            if(object && API[methodOrOptions])\r\n                return API[methodOrOptions].apply(object, args) || this\r\n            else if(!object && (methodOrOptions === undefined ||\r\n                typeof methodOrOptions === \"object\"))\r\n                $t.data(pluginName, new Container($t, methodOrOptions))\r\n\r\n            return this\r\n        });\r\n    };\r\n\r\n}(jQuery, window, 'wf_sortable');\r\n"]}