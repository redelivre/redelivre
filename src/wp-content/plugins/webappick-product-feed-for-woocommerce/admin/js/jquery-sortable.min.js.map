{"version":3,"sources":["jquery-sortable.js"],"names":["Symbol","iterator","nested","$","pluginName","undefined","containerDefaults","drag","groupDefaults","exclude","containerPath","containerSelector","afterMove","distance","draggedClass","handle","itemPath","itemSelector","bodyClass","onDrag","isValidTarget","css","$item","position","addClass","onDragStart","container","removeClass","onMousedown","event","preventDefault","group","options","placeholderClass","removeAttr","_super","target","nodeName","match","placeholder","pullPlaceholder","parentIsContainer","result","sortable","serialize","$parent","$children","extend","data","containerGroups","groupCounter","emptyBox","subContainers","drop","subContainerKey","x","Math","i","length","d","a","b","top","offsetMethod","left","parseInt","el","getRelativePosition","element","sortByDistanceDesc","tolerance","offset","pointer","pos","distances","dimensions","outerWidth","outerHeight","dim","dropProxy","dragProxy","sort","proxy","ContainerGroup","get","this","containers","rootGroup","closestItem","item","disabled","itemDimensions","right","which","find","originalEvent","bottom","on","eventNames","start","dragInit","searchValidTarget","push","setPointer","dragInitDone","prototype","dragging","setupDelayTimer","box","itemContainer","e","toggleListeners","onCancel","detach","delayMet","clearDimensions","clearOffsetParent","relativePointer","lastPointer","sameResultBox","t","offsetParent","lastRelativePointer","getContainer","getContainerDimensions","onDrop","movePlaceholder","lastAppendedItem","$getOffsetParent","containerDimensions","setDimensions","closest","method","getPointer","getItemOffsetParent","that","distanceMet","events","$document","pageX","pageY","currentPointer","clearTimeout","abs","_mouseDelayTimer","o","touches","scroll","_clearDimensions","delay","each","setTimeout","callback","traverse","object","isValidDrag","Container","validTarget","_destroy","inUpperHalf","xCenter","inLeftHalf","index","getItemDimensions","hasChildGroup","items","getContainerGroup","childGroup","childContainers","yCenter","height","path","_serialize","width","removeData","enable","$getChildren","parent","type","isContainer","childType","children","selector","not","map","disable","off","grep","val","destroy","args","$t","API"],"mappings":"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","file":"jquery-sortable.min.js","sourcesContent":["/* ===================================================\n *  jquery-sortable.js v0.9.13\n *  http://johnny.github.com/jquery-sortable/\n * ===================================================\n *  Copyright (c) 2012 Jonas von Andrian\n *  All rights reserved.\n *\n *  Redistribution and use in source and binary forms, with or without\n *  modification, are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  * The name of the author may not be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n *  DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n *  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n *  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n *  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n *  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n * ========================================================== */\n/* eslint-disable */\n!function ( $, window, pluginName, undefined){\n    var containerDefaults = {\n            // If true, items can be dragged from this container\n            drag: true,\n            // If true, items can be droped onto this container\n            drop: true,\n            // Exclude items from being draggable, if the\n            // selector matches the item\n            exclude: \"\",\n            // If true, search for nested containers within an item.If you nest containers,\n            // either the original selector with which you call the plugin must only match the top containers,\n            // or you need to specify a group (see the bootstrap nav example)\n            nested: true,\n            // If true, the items are assumed to be arranged vertically\n            vertical: true\n        }, // end container defaults\n        groupDefaults = {\n            // This is executed after the placeholder has been moved.\n            // $closestItemOrContainer contains the closest item, the placeholder\n            // has been put at or the closest empty Container, the placeholder has\n            // been appended to.\n            afterMove: function ($placeholder, container, $closestItemOrContainer) {\n            },\n            // The exact css path between the container and its items, e.g. \"> tbody\"\n            containerPath: \"\",\n            // The css selector of the containers\n            containerSelector: \"ol, ul\",\n            // Distance the mouse has to travel to start dragging\n            distance: 0,\n            // Time in milliseconds after mousedown until dragging should start.\n            // This option can be used to prevent unwanted drags when clicking on an element.\n            delay: 0,\n            // The css selector of the drag handle\n            handle: \"\",\n            // The exact css path between the item and its subcontainers.\n            // It should only match the immediate items of a container.\n            // No item of a subcontainer should be matched. E.g. for ol>div>li the itemPath is \"> div\"\n            itemPath: \"\",\n            // The css selector of the items\n            itemSelector: \"li\",\n            // The class given to \"body\" while an item is being dragged\n            bodyClass: \"dragging\",\n            // The class giving to an item while being dragged\n            draggedClass: \"dragged\",\n            // Check if the dragged item may be inside the container.\n            // Use with care, since the search for a valid container entails a depth first search\n            // and may be quite expensive.\n            isValidTarget: function ($item, container) {\n                return true\n            },\n            // Executed before onDrop if placeholder is detached.\n            // This happens if pullPlaceholder is set to false and the drop occurs outside a container.\n            onCancel: function ($item, container, _super, event) {\n            },\n            // Executed at the beginning of a mouse move event.\n            // The Placeholder has not been moved yet.\n            onDrag: function ($item, position, _super, event) {\n                $item.css(position)\n            },\n            // Called after the drag has been started,\n            // that is the mouse button is being held down and\n            // the mouse is moving.\n            // The container is the closest initialized container.\n            // Therefore it might not be the container, that actually contains the item.\n            onDragStart: function ($item, container, _super, event) {\n                $item.css({\n                    height: $item.outerHeight(),\n                    width: $item.outerWidth()\n                })\n                $item.addClass(container.group.options.draggedClass)\n                $(\"body\").addClass(container.group.options.bodyClass)\n            },\n            // Called when the mouse button is being released\n            onDrop: function ($item, container, _super, event) {\n                $item.removeClass(container.group.options.draggedClass).removeAttr(\"style\")\n                $(\"body\").removeClass(container.group.options.bodyClass)\n            },\n            // Called on mousedown. If falsy value is returned, the dragging will not start.\n            // Ignore if element clicked is input, select or textarea\n            onMousedown: function ($item, _super, event) {\n                if (!event.target.nodeName.match(/^(input|select|textarea)$/i)) {\n                    event.preventDefault()\n                    return true\n                }\n            },\n            // The class of the placeholder (must match placeholder option markup)\n            placeholderClass: \"placeholder\",\n            // Template for the placeholder. Can be any valid jQuery input\n            // e.g. a string, a DOM element.\n            // The placeholder must have the class \"placeholder\"\n            placeholder: '<li class=\"placeholder\"></li>',\n            // If true, the position of the placeholder is calculated on every mousemove.\n            // If false, it is only calculated when the mouse is above a container.\n            pullPlaceholder: true,\n            // Specifies serialization of the container group.\n            // The pair $parent/$children is either container/items or item/subcontainers.\n            serialize: function ($parent, $children, parentIsContainer) {\n                var result = $.extend({}, $parent.data())\n\n                if(parentIsContainer)\n                    return [$children]\n                else if ($children[0]){\n                    result.children = $children\n                }\n\n                delete result.subContainers\n                delete result.sortable\n\n                return result\n            },\n            // Set tolerance while dragging. Positive values decrease sensitivity,\n            // negative values increase it.\n            tolerance: 0\n        }, // end group defaults\n        containerGroups = {},\n        groupCounter = 0,\n        emptyBox = {\n            left: 0,\n            top: 0,\n            bottom: 0,\n            right:0\n        },\n        eventNames = {\n            start: \"touchstart.sortable mousedown.sortable\",\n            drop: \"touchend.sortable touchcancel.sortable mouseup.sortable\",\n            drag: \"touchmove.sortable mousemove.sortable\",\n            scroll: \"scroll.sortable\"\n        },\n        subContainerKey = \"subContainers\"\n\n    /*\n     * a is Array [left, right, top, bottom]\n     * b is array [left, top]\n     */\n    function d(a,b) {\n        var x = Math.max(0, a[0] - b[0], b[0] - a[1]),\n            y = Math.max(0, a[2] - b[1], b[1] - a[3])\n        return x+y;\n    }\n\n    function setDimensions(array, dimensions, tolerance, useOffset) {\n        var i = array.length,\n            offsetMethod = useOffset ? \"offset\" : \"position\"\n        tolerance = tolerance || 0\n\n        while(i--){\n            var el = array[i].el ? array[i].el : $(array[i]),\n            // use fitting method\n                pos = el[offsetMethod]()\n            pos.left += parseInt(el.css('margin-left'), 10)\n            pos.top += parseInt(el.css('margin-top'),10)\n            dimensions[i] = [\n                pos.left - tolerance,\n                pos.left + el.outerWidth() + tolerance,\n                pos.top - tolerance,\n                pos.top + el.outerHeight() + tolerance\n            ]\n        }\n    }\n\n    function getRelativePosition(pointer, element) {\n        var offset = element.offset()\n        return {\n            left: pointer.left - offset.left,\n            top: pointer.top - offset.top\n        }\n    }\n\n    function sortByDistanceDesc(dimensions, pointer, lastPointer) {\n        pointer = [pointer.left, pointer.top]\n        lastPointer = lastPointer && [lastPointer.left, lastPointer.top]\n\n        var dim,\n            i = dimensions.length,\n            distances = []\n\n        while(i--){\n            dim = dimensions[i]\n            distances[i] = [i,d(dim,pointer), lastPointer && d(dim, lastPointer)]\n        }\n        distances = distances.sort(function  (a,b) {\n            return b[1] - a[1] || b[2] - a[2] || b[0] - a[0]\n        })\n\n        // last entry is the closest\n        return distances\n    }\n\n    function ContainerGroup(options) {\n        this.options = $.extend({}, groupDefaults, options)\n        this.containers = []\n\n        if(!this.options.rootGroup){\n            this.scrollProxy = $.proxy(this.scroll, this)\n            this.dragProxy = $.proxy(this.drag, this)\n            this.dropProxy = $.proxy(this.drop, this)\n            this.placeholder = $(this.options.placeholder)\n\n            if(!options.isValidTarget)\n                this.options.isValidTarget = undefined\n        }\n    }\n\n    ContainerGroup.get = function  (options) {\n        if(!containerGroups[options.group]) {\n            if(options.group === undefined)\n                options.group = groupCounter ++\n\n            containerGroups[options.group] = new ContainerGroup(options)\n        }\n\n        return containerGroups[options.group]\n    }\n\n    ContainerGroup.prototype = {\n        dragInit: function  (e, itemContainer) {\n            this.$document = $(itemContainer.el[0].ownerDocument)\n\n            // get item to drag\n            var closestItem = $(e.target).closest(this.options.itemSelector);\n            // using the length of this item, prevents the plugin from being started if there is no handle being clicked on.\n            // this may also be helpful in instantiating multidrag.\n            if (closestItem.length) {\n                this.item = closestItem;\n                this.itemContainer = itemContainer;\n                if (this.item.is(this.options.exclude) || !this.options.onMousedown(this.item, groupDefaults.onMousedown, e)) {\n                    return;\n                }\n                this.setPointer(e);\n                this.toggleListeners('on');\n                this.setupDelayTimer();\n                this.dragInitDone = true;\n            }\n        },\n        drag: function  (e) {\n            if(!this.dragging){\n                if(!this.distanceMet(e) || !this.delayMet)\n                    return\n\n                this.options.onDragStart(this.item, this.itemContainer, groupDefaults.onDragStart, e)\n                this.item.before(this.placeholder)\n                this.dragging = true\n            }\n\n            this.setPointer(e)\n            // place item under the cursor\n            this.options.onDrag(this.item,\n                getRelativePosition(this.pointer, this.item.offsetParent()),\n                groupDefaults.onDrag,\n                e)\n\n            var p = this.getPointer(e),\n                box = this.sameResultBox,\n                t = this.options.tolerance\n\n            if(!box || box.top - t > p.top || box.bottom + t < p.top || box.left - t > p.left || box.right + t < p.left)\n                if(!this.searchValidTarget()){\n                    this.placeholder.detach()\n                    this.lastAppendedItem = undefined\n                }\n        },\n        drop: function  (e) {\n            this.toggleListeners('off')\n\n            this.dragInitDone = false\n\n            if(this.dragging){\n                // processing Drop, check if placeholder is detached\n                if(this.placeholder.closest(\"html\")[0]){\n                    this.placeholder.before(this.item).detach()\n                } else {\n                    this.options.onCancel(this.item, this.itemContainer, groupDefaults.onCancel, e)\n                }\n                this.options.onDrop(this.item, this.getContainer(this.item), groupDefaults.onDrop, e)\n\n                // cleanup\n                this.clearDimensions()\n                this.clearOffsetParent()\n                this.lastAppendedItem = this.sameResultBox = undefined\n                this.dragging = false\n            }\n        },\n        searchValidTarget: function  (pointer, lastPointer) {\n            if(!pointer){\n                pointer = this.relativePointer || this.pointer\n                lastPointer = this.lastRelativePointer || this.lastPointer\n            }\n\n            var distances = sortByDistanceDesc(this.getContainerDimensions(),\n                    pointer,\n                    lastPointer),\n                i = distances.length\n\n            while(i--){\n                var index = distances[i][0],\n                    distance = distances[i][1]\n\n                if(!distance || this.options.pullPlaceholder){\n                    var container = this.containers[index]\n                    if(!container.disabled){\n                        if(!this.$getOffsetParent()){\n                            var offsetParent = container.getItemOffsetParent()\n                            pointer = getRelativePosition(pointer, offsetParent)\n                            lastPointer = getRelativePosition(lastPointer, offsetParent)\n                        }\n                        if(container.searchValidTarget(pointer, lastPointer))\n                            return true\n                    }\n                }\n            }\n            if(this.sameResultBox)\n                this.sameResultBox = undefined\n        },\n        movePlaceholder: function  (container, item, method, sameResultBox) {\n            var lastAppendedItem = this.lastAppendedItem\n            if(!sameResultBox && lastAppendedItem && lastAppendedItem[0] === item[0])\n                return;\n\n            item[method](this.placeholder)\n            this.lastAppendedItem = item\n            this.sameResultBox = sameResultBox\n            this.options.afterMove(this.placeholder, container, item)\n        },\n        getContainerDimensions: function  () {\n            if(!this.containerDimensions)\n                setDimensions(this.containers, this.containerDimensions = [], this.options.tolerance, !this.$getOffsetParent())\n            return this.containerDimensions\n        },\n        getContainer: function  (element) {\n            return element.closest(this.options.containerSelector).data(pluginName)\n        },\n        $getOffsetParent: function  () {\n            if(this.offsetParent === undefined){\n                var i = this.containers.length - 1,\n                    offsetParent = this.containers[i].getItemOffsetParent()\n\n                if(!this.options.rootGroup){\n                    while(i--){\n                        if(offsetParent[0] != this.containers[i].getItemOffsetParent()[0]){\n                            // If every container has the same offset parent,\n                            // use position() which is relative to this parent,\n                            // otherwise use offset()\n                            // compare #setDimensions\n                            offsetParent = false\n                            break;\n                        }\n                    }\n                }\n\n                this.offsetParent = offsetParent\n            }\n            return this.offsetParent\n        },\n        setPointer: function (e) {\n            var pointer = this.getPointer(e)\n\n            if(this.$getOffsetParent()){\n                var relativePointer = getRelativePosition(pointer, this.$getOffsetParent())\n                this.lastRelativePointer = this.relativePointer\n                this.relativePointer = relativePointer\n            }\n\n            this.lastPointer = this.pointer\n            this.pointer = pointer\n        },\n        distanceMet: function (e) {\n            var currentPointer = this.getPointer(e)\n            return (Math.max(\n                Math.abs(this.pointer.left - currentPointer.left),\n                Math.abs(this.pointer.top - currentPointer.top)\n            ) >= this.options.distance)\n        },\n        getPointer: function(e) {\n            var o = e.originalEvent || e.originalEvent.touches && e.originalEvent.touches[0]\n            return {\n                left: e.pageX || o.pageX,\n                top: e.pageY || o.pageY\n            }\n        },\n        setupDelayTimer: function () {\n            var that = this\n            this.delayMet = !this.options.delay\n\n            // init delay timer if needed\n            if (!this.delayMet) {\n                clearTimeout(this._mouseDelayTimer);\n                this._mouseDelayTimer = setTimeout(function() {\n                    that.delayMet = true\n                }, this.options.delay)\n            }\n        },\n        scroll: function  (e) {\n            this.clearDimensions()\n            this.clearOffsetParent() // TODO is this needed?\n        },\n        toggleListeners: function (method) {\n            var that = this,\n                events = ['drag','drop','scroll']\n\n            $.each(events,function  (i,event) {\n                that.$document[method](eventNames[event], that[event + 'Proxy'])\n            })\n        },\n        clearOffsetParent: function () {\n            this.offsetParent = undefined\n        },\n        // Recursively clear container and item dimensions\n        clearDimensions: function  () {\n            this.traverse(function(object){\n                object._clearDimensions()\n            })\n        },\n        traverse: function(callback) {\n            callback(this)\n            var i = this.containers.length\n            while(i--){\n                this.containers[i].traverse(callback)\n            }\n        },\n        _clearDimensions: function(){\n            this.containerDimensions = undefined\n        },\n        _destroy: function () {\n            containerGroups[this.options.group] = undefined\n        }\n    }\n\n    function Container(element, options) {\n        this.el = element\n        this.options = $.extend( {}, containerDefaults, options)\n\n        this.group = ContainerGroup.get(this.options)\n        this.rootGroup = this.options.rootGroup || this.group\n        this.handle = this.rootGroup.options.handle || this.rootGroup.options.itemSelector\n\n        var itemPath = this.rootGroup.options.itemPath\n        this.target = itemPath ? this.el.find(itemPath) : this.el\n\n        this.target.on(eventNames.start, this.handle, $.proxy(this.dragInit, this))\n\n        if(this.options.drop)\n            this.group.containers.push(this)\n    }\n\n    Container.prototype = {\n        dragInit: function  (e) {\n            var rootGroup = this.rootGroup\n\n            if( !this.disabled &&\n                !rootGroup.dragInitDone &&\n                this.options.drag &&\n                this.isValidDrag(e)) {\n                rootGroup.dragInit(e, this)\n            }\n        },\n        isValidDrag: function(e) {\n            return e.which == 1 ||\n            e.type == \"touchstart\" && e.originalEvent.touches.length == 1\n        },\n        searchValidTarget: function  (pointer, lastPointer) {\n            var distances = sortByDistanceDesc(this.getItemDimensions(),\n                    pointer,\n                    lastPointer),\n                i = distances.length,\n                rootGroup = this.rootGroup,\n                validTarget = !rootGroup.options.isValidTarget ||\n                    rootGroup.options.isValidTarget(rootGroup.item, this)\n\n            if(!i && validTarget){\n                rootGroup.movePlaceholder(this, this.target, \"append\")\n                return true\n            } else\n                while(i--){\n                    var index = distances[i][0],\n                        distance = distances[i][1]\n                    if(!distance && this.hasChildGroup(index)){\n                        var found = this.getContainerGroup(index).searchValidTarget(pointer, lastPointer)\n                        if(found)\n                            return true\n                    }\n                    else if(validTarget){\n                        this.movePlaceholder(index, pointer)\n                        return true\n                    }\n                }\n        },\n        movePlaceholder: function  (index, pointer) {\n            var item = $(this.items[index]),\n                dim = this.itemDimensions[index],\n                method = \"after\",\n                width = item.outerWidth(),\n                height = item.outerHeight(),\n                offset = item.offset(),\n                sameResultBox = {\n                    left: offset.left,\n                    right: offset.left + width,\n                    top: offset.top,\n                    bottom: offset.top + height\n                }\n            if(this.options.vertical){\n                var yCenter = (dim[2] + dim[3]) / 2,\n                    inUpperHalf = pointer.top <= yCenter\n                if(inUpperHalf){\n                    method = \"before\"\n                    sameResultBox.bottom -= height / 2\n                } else\n                    sameResultBox.top += height / 2\n            } else {\n                var xCenter = (dim[0] + dim[1]) / 2,\n                    inLeftHalf = pointer.left <= xCenter\n                if(inLeftHalf){\n                    method = \"before\"\n                    sameResultBox.right -= width / 2\n                } else\n                    sameResultBox.left += width / 2\n            }\n            if(this.hasChildGroup(index))\n                sameResultBox = emptyBox\n            this.rootGroup.movePlaceholder(this, item, method, sameResultBox)\n        },\n        getItemDimensions: function  () {\n            if(!this.itemDimensions){\n                this.items = this.$getChildren(this.el, \"item\").filter(\n                    \":not(.\" + this.group.options.placeholderClass + \", .\" + this.group.options.draggedClass + \")\"\n                ).get()\n                setDimensions(this.items, this.itemDimensions = [], this.options.tolerance)\n            }\n            return this.itemDimensions\n        },\n        getItemOffsetParent: function  () {\n            var offsetParent,\n                el = this.el\n            // Since el might be empty we have to check el itself and\n            // can not do something like el.children().first().offsetParent()\n            if(el.css(\"position\") === \"relative\" || el.css(\"position\") === \"absolute\"  || el.css(\"position\") === \"fixed\")\n                offsetParent = el\n            else\n                offsetParent = el.offsetParent()\n            return offsetParent\n        },\n        hasChildGroup: function (index) {\n            return this.options.nested && this.getContainerGroup(index)\n        },\n        getContainerGroup: function  (index) {\n            var childGroup = $.data(this.items[index], subContainerKey)\n            if( childGroup === undefined){\n                var childContainers = this.$getChildren(this.items[index], \"container\")\n                childGroup = false\n\n                if(childContainers[0]){\n                    var options = $.extend({}, this.options, {\n                        rootGroup: this.rootGroup,\n                        group: groupCounter ++\n                    })\n                    childGroup = childContainers[pluginName](options).data(pluginName).group\n                }\n                $.data(this.items[index], subContainerKey, childGroup)\n            }\n            return childGroup\n        },\n        $getChildren: function (parent, type) {\n            var options = this.rootGroup.options,\n                path = options[type + \"Path\"],\n                selector = options[type + \"Selector\"]\n\n            parent = $(parent)\n            if(path)\n                parent = parent.find(path)\n\n            return parent.children(selector)\n        },\n        _serialize: function (parent, isContainer) {\n            var that = this,\n                childType = isContainer ? \"item\" : \"container\",\n\n                children = this.$getChildren(parent, childType).not(this.options.exclude).map(function () {\n                    return that._serialize($(this), !isContainer)\n                }).get()\n\n            return this.rootGroup.options.serialize(parent, children, isContainer)\n        },\n        traverse: function(callback) {\n            $.each(this.items || [], function(item){\n                var group = $.data(this, subContainerKey)\n                if(group)\n                    group.traverse(callback)\n            });\n\n            callback(this)\n        },\n        _clearDimensions: function  () {\n            this.itemDimensions = undefined\n        },\n        _destroy: function() {\n            var that = this;\n\n            this.target.off(eventNames.start, this.handle);\n            this.el.removeData(pluginName)\n\n            if(this.options.drop)\n                this.group.containers = $.grep(this.group.containers, function(val){\n                    return val != that\n                })\n\n            $.each(this.items || [], function(){\n                $.removeData(this, subContainerKey)\n            })\n        }\n    }\n\n    var API = {\n        enable: function() {\n            this.traverse(function(object){\n                object.disabled = false\n            })\n        },\n        disable: function (){\n            this.traverse(function(object){\n                object.disabled = true\n            })\n        },\n        serialize: function () {\n            return this._serialize(this.el, true)\n        },\n        refresh: function() {\n            this.traverse(function(object){\n                object._clearDimensions()\n            })\n        },\n        destroy: function () {\n            this.traverse(function(object){\n                object._destroy();\n            })\n        }\n    }\n\n    $.extend(Container.prototype, API)\n\n    /**\n     * jQuery API\n     *\n     * Parameters are\n     *   either options on init\n     *   or a method name followed by arguments to pass to the method\n     */\n    $.fn[pluginName] = function(methodOrOptions) {\n        var args = Array.prototype.slice.call(arguments, 1)\n\n        return this.map(function(){\n            var $t = $(this),\n                object = $t.data(pluginName)\n\n            if(object && API[methodOrOptions])\n                return API[methodOrOptions].apply(object, args) || this\n            else if(!object && (methodOrOptions === undefined ||\n                typeof methodOrOptions === \"object\"))\n                $t.data(pluginName, new Container($t, methodOrOptions))\n\n            return this\n        });\n    };\n\n}(jQuery, window, 'wf_sortable');\n"]}